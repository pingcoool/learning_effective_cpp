条款 01: 视 c++ 为一个语言联邦
========
c++ 是一个多重泛型编程语言, 同时支持: 面向过程, 面向对象, 函数式编程, 泛型编程, 元编程. 这些无与伦比的能力和弹性给了程序员更加丰富的选择. 这自然也引发了一些迷惑: 在使用 c++ 编程的过程中, 怎样的方式是 "适当用法".
<br> 
c++ 可以看作是四种语言组成的联邦:

# 1. c 语言
这一点无需多言, c++ 的设计初衷是对 c 编程语言的改进, 向前兼容 c 语言. 这为 c++ 提供了强大的生命力, 但也为其留下了些历史包袱: 比如 c++ 中, 对象以默认参数初始化时, 和 c 中的函数定义相冲突等. 但是瑕不掩瑜, c++ 在 c 之外提供了更加高级的用法.
# 2. 面向对象的 c++
面向对象编程提供了封装, 继承, 多态等用法, 将面向过程中机械地初始化和释放资源等环节形象地等价到了对象的生命周期管理中. 使得 c++ 的表达方式站在了一个更高的层次, 允许程序员更方便地做自顶向下的程序构建. 当然面向对象同样带来了一些问题: 如内存管理, 将对象以参数方式进行传递时, 会涉及大量的内存拷贝, 由此 c++ 引入了对象的拷贝构造, 赋值构造, 甚至引入了引用和 std::move 的方式来减少对象的拷贝. 
<br>
> 这里笔者要说一下自己的看法 ( 哈哈, 我也有一天能够自称为 "笔者" 了 ) : 
> <br>
> 我是一个强烈推崇 rust 的程序员, 至于为什么不去搞个 learning_rust 项目, 我只能说, 那才是我的终极目标. 如果我不把 c++ 学到一定深度, 我怎么会有底气地说 rust 才是永远滴神呢.
> <br>
> c++ 中对内存的管理过于豪放, 默认的值传递就是拷贝所有成员变量, "隐式地" 进行一些开销较大的操作, 这使得 c++ 程序员不得不为了效率而使用 std::move 和引用. 而 rust 在这方面做得足够严谨: rust 中, 需要进行结构体拷贝的操作一定要 "显式地" 指出, 否则默认将所有权转移. 可以说, rust 是将 c++ 的最佳实践固化到基本语法中的编程语言.
# 3. 泛型编程 c++
泛型编程打开了又一个新世界的大门: 它允许程序员以一种独立于任何特定类型的方式编写代码, 并且编译后生成的代码仍然保持最高的执行效率, 无需在执行时产生额外的动态绑定等开销.
# 4. STL
STL (标准模板库) 是一套功能强大的 c++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构. STL 避免了程序员在基本数据结构上 "重复造轮子". 当然, 使用 STL 时, 请注意严格遵守它的规约: 工程中常用的 std::map, 你真的完全知道它的用法吗?
```c++
#include <iostream>
#include <map>
#include <string_view>
 
void print_map(std::string_view comment, const std::map<std::string, int>& m)
{
    std::cout << comment;
    for (const auto& [key, value] : m) {
        std::cout << key << " = " << value << "; ";
    }
    std::cout << "\n";
}
 
int main()
{
    // Create a map (that map to integers)
    std::map<std::string, int> m;
 
    print_map("Initial map: ", m);

    if (m["key0"]) {
        std::cout << "contains key0" << std::endl;
    }
 
    print_map("Updated map: ", m);

    /* 
     * Initial map: 
     * Updated map: key0 = 0;
     */
}
```
非常遗憾的是, 真的有人用上面这种方式判断 map 中元素是否存在, 而且更加遗憾的是, 如果 map 中没有 key0 这个元素, if 条件中的代码的确不会执行. 但这个程序会向 map 中添加一个元素. 这样一个 bug 我们在实际项目中, 三个人排查了一整天. 
<br>
如果你说上面这个错误你绝对不会犯, 那你一定要看看下面这个操作:
```c++
int main()
{
    // Create a map (that map to integers)
    std::map<std::string, int> m;
 
    print_map("Initial map: ", m);

    m["key0"] = 1;
    m.emplace(std::make_pair("key0", 2));
 
    print_map("Updated map: ", m);

    /* 
     * Initial map: 
     * Updated map: key0 = 1;
     */
}
```
没错, map 中的元素没有被更新, 这个 bug 我们也用了至少两个小时才排查出来.
<br>
总之, 在使用 STL 时, 一定注意仔细阅读接口文档, 严格遵守规约才能够做到准确和高效.
<br>
回到我们的主题, c++ 是上面四种子语言的联合. 当你从某个子语言切换到另一个时, 你需要遵守的高效编程规范可能会发生变化: 比如当你使用 c 语言内置类型时, 直接使用值传递会比引用传递更高效, 毕竟引用的本质是加了语法糖的指针 (有兴趣的话, 可以查看一下汇编结果); 而当你传递一个自定义的对象类型时, 使用引用或指针就是一个非常高效的方式了, 这样能够避免构造临时对象和成员变量的拷贝; 而如果你在使用 STL 的话, 迭代器和函数对象都是在 c 指针上塑造出来的, 所以值传递的效率更高.
<br>

记住下面这句话
========
# c++ 高效编程守则视状况而变化, 取决于你使用 c++ 的哪一部分

